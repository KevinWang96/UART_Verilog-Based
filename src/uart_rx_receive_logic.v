/*
 * @Author: Yihao Wang
 * @Date: 2020-05-02 20:25:43
 * @LastEditTime: 2020-05-02 22:07:20
 * @LastEditors: Please set LastEditors
 * @Description: 
 *      a. Receiving logic of Rx side driven by sample clock (generated by clk generator)
 *      b. Supporting error detection by checking 1-bit parity (MSB) to report error
 *      c. Reports data frame format error if the last bit is not stop bit 
 * @FilePath: /uart/src/uart_rx_receive_logic.v
 */
 `timescale 1ns/1ps
 module uart_rx_receive_logic #(
     parameter  FRAME_WIDTH =   8
 )
 (
     sample_clk,
     reset,
     uart_rx_din,
     uart_rx_dout,
     uart_rx_done,
     uart_rx_data_error,
     uart_rx_frame_error
 );
    
    input                       sample_clk;             // sample clock (16 X bit_clk), positive edge triggering
    input                       reset;                  // sync reset
    input                       uart_rx_din;
    output  [0:FRAME_WIDTH - 1] uart_rx_dout;           // parallel data out
    output  reg                 uart_rx_done;
    output  reg                 uart_rx_data_error;     // parity checking failed
    output  reg                 uart_rx_frame_error;    // frame error: the last bit is not stop bit

    // FSM state definition:
    localparam  IDLE    =   3'b000,
                INIT    =   3'b001,
                SAMPLE  =   3'b010,
                WAIT    =   3'b011,
                DONE    =   3'b100;
    
    wire                                negedge_detect;             // detected negative edge of din
    reg                                 din_delay;                  // delay din by 1 clock

    reg [0:2]                           state;                      // state memory of FSM
    reg [0:$clog2(FRAME_WIDTH + 1) - 1] bit_counter;
    reg [0:4]                           clk_counter;
    reg [0:3]                           sample_shift_reg_bit;       // performs 4 times sampling for each bit
    reg [0:FRAME_WIDTH - 1]             sample_shift_reg_data;  // used to parallelize serial data

    wire                                sample_bit;             // we sample each bit 4 times
                                                                // if 3 of 4 bits are 1, we say the sample bit is 1
                                                                // otherwise, sample bit is 0;

    assign  sample_bit      =   (sample_shift_reg_bit[0] & sample_shift_reg_bit[1] & sample_shift_reg_bit[2]) |
                                (sample_shift_reg_bit[0] & sample_shift_reg_bit[1] & sample_shift_reg_bit[3]) |
                                (sample_shift_reg_bit[0] & sample_shift_reg_bit[2] & sample_shift_reg_bit[3]) |
                                (sample_shift_reg_bit[1] & sample_shift_reg_bit[2] & sample_shift_reg_bit[3]) ;

    assign  negedge_detect  =   din_delay & (~uart_rx_din);

    assign  uart_rx_dout    =   sample_shift_reg_data; 
    
    always @(posedge sample_clk) begin
        if(reset) din_delay <= 0;
        else din_delay <= uart_rx_din;
    end

    // FSM
    always @(posedge sample_clk) begin
        if(reset) begin
            state <= IDLE;
            bit_counter <= 0;
            clk_counter <= 0;
            sample_shift_reg_bit <= 0;
            sample_shift_reg_data <= 0;
            uart_rx_data_error <= 0;
            uart_rx_frame_error <= 0;
        end
        else
            case(state)
                IDLE : begin
                    clk_counter <= 0;
                    if(negedge_detect) 
                        state <= INIT;
                end
                INIT : begin
                    if(clk_counter != 21)
                        clk_counter <= clk_counter + 1;
                    else begin : shift_loop_0 // clk_counter == 21
                        integer i;
                        clk_counter <= 0;
                        bit_counter <= 0;
                        
                        // shifting
                        sample_shift_reg_bit[0] <= uart_rx_din;
                        for(i = 1; i <= 3; i = i + 1)
                            sample_shift_reg_bit[i] <= sample_shift_reg_bit[i - 1];

                        state <= SAMPLE;
                    end
                end
                SAMPLE : begin : shift_loop_1
                    integer i;
                    if(clk_counter != 3) begin
                        clk_counter <= clk_counter + 1;

                        // shifting
                        sample_shift_reg_bit[0] <= uart_rx_din;
                        for(i = 1; i <= 3; i = i + 1)
                            sample_shift_reg_bit[i] <= sample_shift_reg_bit[i - 1];
                    end
                    else begin : shift_loop_2 // clk_counter == 3
                        integer i;
                        bit_counter <= bit_counter + 1;
                        clk_counter <= 0;

                        if(bit_counter == FRAME_WIDTH) // it is parity bit itsead of data bit
                            uart_rx_data_error <= parity_check(sample_shift_reg_data, sample_bit);
                        else begin
                            sample_shift_reg_data[0] <= sample_bit; ///////////////////////
                            for(i = 1; i < FRAME_WIDTH; i = i + 1)
                                sample_shift_reg_data[i] <= sample_shift_reg_data[i - 1];
                        end
                        
                        state <= WAIT;
                    end
                end
                WAIT : begin
                    if(clk_counter != 11) clk_counter <= clk_counter + 1;
                    else begin : shift_loop_3
                        integer i;

                        clk_counter <= 0;

                        // shifting
                        sample_shift_reg_bit[0] <= uart_rx_din;
                        for(i = 0; i <= 3; i = i + 1)
                            sample_shift_reg_data[i] <= sample_shift_reg_data[i - 1];

                        if(bit_counter == FRAME_WIDTH + 1)
                            state <= DONE;
                        else    
                            state <= SAMPLE;
                    end
                end
                DONE : begin : shift_loop_4
                    integer i;

                    if(clk_counter < 3) begin
                        clk_counter <= clk_counter + 1;

                        // shifting
                        sample_shift_reg_bit[0] <= uart_rx_din;
                        for(i = 1; i <= 3; i = i + 1)
                            sample_shift_reg_bit[i] <= sample_shift_reg_bit[i - 1];
                    end
                    else if(clk_counter == 3) begin
                        clk_counter <= clk_counter + 1;
                        uart_rx_done <= 1;

                        if(sample_bit) uart_rx_frame_error <= 0;
                        else uart_rx_frame_error <= 1;
                    end 
                    else state <= IDLE;
                end
            endcase
    end

    // Error detection function
    function parity_check (data, parity);
        input   [0:FRAME_WIDTH - 1] data;
        input                       parity;
    begin : check
        reg temp;
        integer i;
        temp = 0;
        for(i = 0; i < FRAME_WIDTH; i = i + 1)
            temp = temp ^ data[i];
        
        parity_check = (temp == parity);
    end
    endfunction

 endmodule