/*
 * @Author: your name
 * @Date: 2020-05-02 23:21:05
 * @LastEditTime: 2020-05-03 00:42:53
 * @LastEditors: Please set LastEditors
 * @Description: 
 *      a. Receiving logic of Rx side driven by sample clock (generated by clk generator)
 *      b. Supporting error detection by checking 1-bit parity (MSB) to report error
 *      c. Reports data frame format error if the last bit is not stop bit 
 * @FilePath: /uart/src/uart_rx_receive_logic.v
 */
 `timescale 1ns/1ps
 module uart_rx_receive_logic #(
     parameter  FRAME_WIDTH =   8
 )
 (
     sample_clk,
     reset,
     uart_rx_din,
     uart_rx_dout,
     uart_rx_done,
     uart_rx_data_error,
     uart_rx_frame_error
 );
    
    input                       sample_clk;             // sample clock (16 X bit_clk), positive edge triggering
    input                       reset;                  // async reset
    input                       uart_rx_din;
    output  [0:FRAME_WIDTH - 1] uart_rx_dout;           // parallel data out
    output                      uart_rx_done;
    output                      uart_rx_data_error;     // parity checking failed
    output                      uart_rx_frame_error;    // frame error: the last bit is not stop bit

    // FSM states definition
    localparam  IDLE    =   2'b00,
                INIT    =   2'b01,
                SAMPLE  =   2'b10,
                DONE    =   2'b11;
                
    reg [0:4]               clk_counter;        // counts sample_clk
    reg [0:FRAME_WIDTH]     bit_counter;        // counts data bits
    reg [0:FRAME_WIDTH - 1] shift_reg;          // parallelizer
    reg                     parity_check_flag;  // 1-bit parity checking results (1 means error) 
    reg                     frame_check_flag;   // 1-bit frame checking results (1 means error)  
    reg [0:1]               state;              // state memory of FSM               

    reg                     din_delay;          // used for negedge detection
    wire                    negedge_detect;     // negative edge detected
    reg                     parity_cur;         // current parity bit

    // Generates current parity
    always @(*) begin : parity_generator_loop
        integer i;
        parity_cur = 0;
        for(i = 0; i < FRAME_WIDTH; i = i + 1)
            parity_cur = parity_cur ^ shift_reg[i];
    end

    // Negedge detection of uart_rx_din
    always @(posedge sample_clk, posedge reset) begin
        if(reset) din_delay <= 0;
        else din_delay <= uart_rx_din;
    end
    assign  negedge_detect  =   (~uart_rx_din) & din_delay;

    // FSM
    always @(posedge sample_clk, posedge reset) begin
        if(reset) begin
            clk_counter <= 0;
            bit_counter <= 0;
            shift_reg <= 0;
            parity_check_flag <= 0;
            frame_check_flag <= 0;
            state <= IDLE;
        end
        else 
            case(state)
                IDLE : 
                    if(negedge_detect) begin
                        clk_counter <= 0;
                        state <= INIT;
                    end
                INIT : begin
                    if(clk_counter == 6) begin
                        clk_counter <= 0;
                        bit_counter <= 0;
                        state <= SAMPLE;
                    end
                    else 
                        clk_counter <= clk_counter + 1;
                end
                SAMPLE : begin : shift_loop
                    integer i;

                    if(clk_counter == 15) begin
                        bit_counter <= bit_counter + 1;
                        clk_counter <= 0;

                        if(bit_counter < FRAME_WIDTH) begin // data bit
                            shift_reg[0] <= uart_rx_din;
                            for(i = 1; i < FRAME_WIDTH; i = i + 1)
                                shift_reg[i] <= shift_reg[i - 1];
                        end
                        else if(bit_counter == FRAME_WIDTH) begin // parity bit
                            if(uart_rx_din == parity_cur)
                                parity_check_flag <= 0;
                            else 
                                parity_check_flag <= 1; // reports error
                        end
                        else begin // stop bit
                            state <= DONE;
                            if(uart_rx_din == 1)
                                frame_check_flag <= 0;
                            else
                                frame_check_flag <= 1;
                        end
                    end
                    else 
                        clk_counter <= clk_counter + 1;
                end
                DONE : state <= IDLE;
            endcase
    end

    assign  uart_rx_done        =   (state == DONE);
    assign  uart_rx_data_error  =   parity_check_flag;
    assign  uart_rx_frame_error =   frame_check_flag;
    assign  uart_rx_dout        =   shift_reg;

 endmodule  